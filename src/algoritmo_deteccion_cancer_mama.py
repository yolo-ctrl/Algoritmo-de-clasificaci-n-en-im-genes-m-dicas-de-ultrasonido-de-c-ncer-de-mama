# -*- coding: utf-8 -*-
"""algoritmo_deteccion_cancer_mama.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wHZ4DfW7E7jFsI_AWAKvIcTMzAJj2a-F

# Algoritmo deteccion cancer de mama
Integrantes:

Leisson Duwer Polo Villalobos 2420171094;2420171094@estudiantesunibague.edu.co

Manuel Felipe Sarmiento Gonzale 2420142004;2420142004@estudiantesunibague.edu.co

Universidad de Ibagué

Facultad de Ingeniería electrónica

Inteligencia Artificial

Ing. Harold Fabian Murcia Moreno.

# METODO PARA EJECUCION DEL CODIGO

* Ejecutar el primer bloque.
* Cargar el archivo Kaggle.json adjunto en la entrega.
* Ejecutar celda por celda
"""

!pip install kaggle
from google.colab import files
files.upload()
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!kaggle datasets download -d aryashah2k/breast-ultrasound-images-dataset
!ls
import zipfile
zip_ref = zipfile.ZipFile("breast-ultrasound-images-dataset.zip", "r")
zip_ref.extractall("files")
print(zip_ref.namelist)
zip_ref.close()

"""# IMPORTACION Y ACONDICIOMANIENTO DE DATOS


---



**Se importa las diferentes librerias tales como os , numpy, sklearn y open cv.todas estas librerias nos ayudaran a leer la base de datos, realizar las operaciones matriciales y para graficar los datos y por supuesto para aplicar las diferentes funciones de clasificacion.**
"""

import numpy as np
import cv2
import os
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import r2_score, mean_squared_error, confusion_matrix, precision_score, recall_score, accuracy_score, f1_score
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import precision_recall_fscore_support
from sklearn.naive_bayes import GaussianNB


direccion = r'/content/files/Dataset_BUSI_with_GT/'
# crear listas vacías para contener las imágenes que se están leyendo

x_imagen = []
y_target = []

target = os.listdir(direccion)

for dirnombre in target:
  dir_archivo = os.path.join(direccion, dirnombre)
  for file in os.listdir(dir_archivo):
    nombre_arch = os.path.join(dir_archivo, file)
  #  print(nombre_arch)
    imagen = cv2.imread(nombre_arch,0)
    imagen = cv2.resize(imagen, (300,300))
    x_imagen.append(imagen.flatten())
    if (dirnombre == 'benign'):
      y_target.append(0)
    elif (dirnombre == 'malignant'):
      y_target.append(1)
    elif (dirnombre == 'normal'):
      y_target.append(2)

x_imagen_n = np.array(x_imagen)
print(x_imagen_n.shape)

y_target_n = np.array(y_target)
print(y_target_n)

# dividir datos de entrenamiento y datos de prueba
x_train, x_test, y_train, y_test = train_test_split(x_imagen_n, y_target_n, test_size=0.3, random_state=0)

# entrenamiento del modelo de clasificacion randomforest
clf_rfc = RandomForestClassifier().fit(x_train, y_train)

# evaluar el modelo con datos de prueba
y_pred_rfc = clf_rfc.predict(x_test)
print('prediccion',y_pred_rfc)
print('valores t',y_test)
#print(precision_score(y_test, y_pred_rfc, average='weighted'))
#print(accuracy_score(y_test, y_pred_rfc))  


F1 = f1_score(y_test, y_pred_rfc, average='micro')
print("randomforest F1:",F1*100 ,"%")
PR=precision_recall_fscore_support(y_test,y_pred_rfc)
print(PR)

from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
N=900
pred_rfc = clf_rfc.predict(x_imagen_n[N-1:N])
print(pred_rfc)
print(y_target_n[N])
#plt.imshow(x_imagen[N])

# entrenamiento del modelo de clasificacion arbol de deciciones 
algoritmo = DecisionTreeClassifier()
algoritmo.fit(x_train, y_train)

# evaluar el modelo con datos de prueba
Y_pred = algoritmo.predict(x_test)
#print('Precisión Decision Tree Classifier: {}'.format(algoritmo.score(x_train, y_train)))


#print("Pred ", Y_pred)
#print("Target:", y_test.T)
F11 = f1_score(y_test, Y_pred.T, average='micro')

print("Arbol de decisiones F1:",F11*100 ,"%")
PR1=precision_recall_fscore_support(y_test,Y_pred.T)
#print(PR1)


# entrenamiento del modelo de clasificacion KNeighbors 
algoritmo1 = KNeighborsClassifier(n_neighbors=5)
algoritmo1.fit(x_train, y_train)
# evaluar el modelo con datos de prueba
Y_pred1 = algoritmo1.predict(x_test)
#print('Precisión K Neighbors: {}'.format(algoritmo1.score(x_train, y_train)))

#print("Pred ", Y_pred1)
#print("Target:", y_test.T)
F12 = f1_score(y_test, Y_pred1.T, average='micro')

print("K Neighbors F1:",F12*100 ,"%")
PR2=precision_recall_fscore_support(y_test,Y_pred1.T)
#print(PR2)

# entrenamiento del modelo de clasificacion SVC
algoritmo2 = SVC()
algoritmo2.fit(x_train, y_train)

# evaluar el modelo con datos de prueba
Y_pred2 = algoritmo2.predict(x_test)
#print('Precisión SVC: {}'.format(algoritmo2.score(x_train, y_train)))

#print("Pred ", Y_pred2)
#print("Target:", y_test.T)
F14 = f1_score(y_test, Y_pred2.T, average='micro')

print("SVC F1:",F14*100 ,"%")
PR2=precision_recall_fscore_support(y_test,Y_pred2.T)
#print(PR2)

# entrenamiento del modelo de clasificacion regresion logistica
algoritmo3 = LogisticRegression()
algoritmo3.fit(x_train, y_train)
Y_pred3 = algoritmo3.predict(x_test)
#print('Precisión Logistic Regression: {}'.format(algoritmo3.score(x_train, y_train)))

#print("Pred ", Y_pred3)
#print("Target:", y_test.T)
F14 = f1_score(y_test, Y_pred3.T, average='micro')

print("regresion logistica F1:",F14*100 ,"%")
PR3=precision_recall_fscore_support(y_test,Y_pred3.T)
#print(PR3)


# Crea el clasificador Bayesiano
gnb = GaussianNB() 
# Entrenar Clasificador
gnb = gnb.fit(x_train, y_train)
# Prediccion
y_pred_NB = gnb.predict(x_test)

#print("Pred ", Y_pred_NB)
#print("Target:", y_test.T)
F15 = f1_score(y_test, y_pred_NB.T, average='micro')

print("bayesiano F1:",F15*100 ,"%")
PR5=precision_recall_fscore_support(y_test,y_pred_NB.T)
#print(PR5)